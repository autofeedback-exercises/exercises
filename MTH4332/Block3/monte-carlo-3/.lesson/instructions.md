# Writing a Monte Carlo code

You now have all the pieces that you need in order to write a Monte Carlo code to simulate the 2D Ising model.  In this exercise you are thus going 
put all the ideas you have learned together and you are going to write your own Monte Carlo code for simulating the 2D Ising model.  

I have written an outline for your code in the file `main.py`, which you need to fill in. As part of this outline I have written a function called 
`monte_carlo` to perform Monte Carlo simulations.  At the bottom of `main.py` I have then used this function to run a short Monte Carlo simulation.
Once you complete the function and run the code a graph will be generated that will show you the energies that were sampled during your Monte Carlo
run.

__Your task is to complete the function `monte_carlo`__.  This function takes the following 7 input arguments:

* `N` - the number of production steps of Monte Carlo to perform.  Statistics are accumulated during the production phase of the run.

* `equil` - the number of equilibration steps that should be performed before starting the production phase of the simulation.  All the states that are visited during this equilibration phase are discarded.  They are not used when accumulating any averages and statistics.

* `stride` - the frequency that should be used for collecting statistics during the production phase of the calculation.  Averages and statistics are only updated every `stride` steps.  States visted on steps that are not a multiple of stride are discarded and not used when accumulating averages and statistics.

* `L` - the size of the sysstem.  An LxL array of spins in simulated.

* `H` - the magnetic field strength

* `T` - the temperature

* `seed` - the random number seed (see the footnote at the end of the instructions for further details).

`monte_carlo` should return a NumPy array with `N/stride` elements.  As you can see from the outline, the elements of this array should be the energies of the states that have been visted during the Monte Carlo simulation.

To complete the function you need to do the following tasks:

1. Write code to calculate the energy of the initial configuration.  The initial configuration is set up in the NumPy array called `spins`.  To calculate the energy of this configuration you will need to use what you learned in the exercises on evaluating these spin hamiltonians.  The energy should be stored in a variable called `eng`.

2. Write code to calculate the energy of the new state that is generated by the trial move.  You will notice that I generate a random integer `move`.  This variable determines the random move that should be performed.  If `move` is equal to `L*L` then the trial move involves flipping every spin.  If `move` is equal to any other value then the `spin[j,k]` is flipped.  You should set the variable `neweng` equal to the energy of the new configuration.  To complete this task you will need to use what you learned in the exercise that came just before this one.

3. You need to decide whether or not to accept the trial move.  You need to complete the if statement that contains a call to the `min` function.  To complete this line of the code you will need to use what you learned in the first exercise on Monte Carlo that you completed.  The exercise where you used Monte Carlo to sample a harmonic potential.

4. You need to update the `spins` array so that it contains the trial move when the trial move is accepted. If this updating of `spins` is not performed then we cannot determine the energy of the trial move when we start the new move on the next pass through the loop.

Once you have added these four bits of code and run the program a graph will be generated that shows the energy that the system adopted over the course of the simulation.  You should see the energy settle down to a constant value and that it then fluctuates around that constant value over the course of the simulation.

===

## On random numbers

The random numbers that computers generate are pseudo random. If you are running Monte Carlo calculations this is usually an annoyance as if you are not careful your results are affected by the fact that the series of 
moves that you performed is not really random.  However, when I was writing the code that tests your work this lack of randomness was enormously convnient.  Basically, I test that your Monte Carlo code works corrected by running the same 
Monte Carlo calculation you did using the exact same sequence of random numbers that you used in your implementation.  I am able to do this because I pass the variable `seed` to your function.  This variable is then passed to NumPy and is 
used to determine how the pseudo random variables it generates are determined.  When I run the Monte Carlo and when you run the Monte Carlo this variable `seed` takes the same value.  The random numbers we generate are thus the same.  The 
result you get from your code and the result that I get from my test code are thus identical.
